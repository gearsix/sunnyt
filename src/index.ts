// nodejs
import { stdout } from 'process'
import { createServer } from 'http'
import { readFile, writeFile } from 'fs'
// npm
import { render } from 'mustache'
// internal
import { Config, SunriseSunset } from './sunnyt'

const cfg: Config = require('./config.json')

const outfile: string = './sunnyt.html'
const template: string = './output.mst'

/**
 * main runtime, call `renderTemplate` and create a HTTP server on
 * port 8000 serving the HTML output
**/
let emptyDataset = initDataset(cfg.datasetSize)
requestData(emptyDataset, cfg.requestLimit).then(async (dataset: SunriseSunset[]) => {
  try {
    if (dataset.length === 0)
      throw(new Error('empty dataset'))
    let templateString = await new Promise<string>((resolve) => {
      readFile(template, async (err, templateBuffer) => {
        if (err) throw err
        resolve(templateBuffer.toString())
      })
    })
    const html = await renderTemplate(templateString, dataset)
    const server = createServer(async (request, response) => {
      response.writeHead(200, { "Content-Type": "text/html" })
      response.write(html)
      response.end()
    })
    console.log('Serving content on http://localhost:8080/')
    server.listen(8000)
  } catch (err) {
    console.error(err.message)
  }
})

/**
 * Generate a dataset (using `initDataset()` and `requestData()`).
 * Then format that data to be used with `render` against the `template` file.
**/
function renderTemplate(template: string, dataset: SunriseSunset[]): Promise<string> {
  const earliestIndex = findEarliestSunrise(dataset)
  const templateData = {
    data: dataset.map((data, index) => formatData(data, index)),
    datasize: dataset.length,
    earliest: formatData(dataset[earliestIndex], earliestIndex)
  }
  return render(template, templateData)
}

/**
 * Find the index of the item in `dataset` with the earliest `.data.sunrise`.
**/
function findEarliestSunrise(dataset: SunriseSunset[]): number {
  let earliestIndex: number = 0
  dataset.forEach((item, index) => {
    if (index === 0 || item.data === undefined)
      return
    if (item.data.sunrise > dataset[earliestIndex].data.sunrise)
      earliestIndex = index
  })
  return earliestIndex
}

/**
 * Format a `SunriseSunset` into an object to be parsed by the output template
**/
function formatData(item: SunriseSunset, id: number): Object {
  return {
    id: id+1, // 1-n instead of 0-n
    lat: item.lat,
    lng: item.lng,
    sunrise: (item.data === undefined) ? 'no data' : item.data.sunrise.toUTCString(),
    daylen: (item.data === undefined) ? 'no data' : item.data.dayLength.toTimeString()
  }
}


/**
 * initDataset initialsies a `SunriseSunset[]` of size `cfg.datasetSize`.
 * All constructor values of the generates datas are left blank and
 * get generated by the class constructor (see #SunriseSunset).
**/
function initDataset(size: number): SunriseSunset[] {
  let ds: SunriseSunset[] = []
  for (let i = 0; i < size; i++)
    ds.push(new SunriseSunset())
  return ds
}

/**
 * requestData calls the `.requestData()` of all items in `dataset`.
 * The number of concurrent requests made is limited by `cfg.requestLimit`,
 * these requests are made in batches - the next batch is requested after
 * all responses from the previous batch have been recieved.
 * The returned `SunriseSunset[]` of the returned `Promise` will be `dataset`
 * with it's `.data` variable updated (using `.requestData()`).
**/
function requestData(dataset: SunriseSunset[], requestLimit: number): Promise<SunriseSunset[]> {
  return new Promise<SunriseSunset[]>(async(resolve) => {
    const datasetSize = dataset.length

    for (let index = 0; index < datasetSize; index += requestLimit) {
      let numReqs = (index + requestLimit > datasetSize)
    		? dataset.length : index + requestLimit 
      let reqs: Promise<void>[] = []
      for (let r = index; r < numReqs; r++)
        reqs.push(dataset[r].requestData().catch(console.error))
      console.log(`${numReqs} / ${dataset.length} requests...\r`)
      await Promise.all(reqs)
    }
	
    dataset = dataset.filter(item => (
      item.data !== undefined && item.data.sunrise.getFullYear() !== 1970
    ))
    if (dataset.length < datasetSize) {
      let numMissingData = datasetSize - dataset.length
      console.log(`found ${numMissingData} items with invalid or missing data`)
      dataset = dataset.concat(await requestData(initDataset(numMissingData), requestLimit))
    }

    resolve(dataset)
  })
}
