// nodejs
import { stdout } from 'process'
import { createServer } from 'http'
import { readFile, writeFile } from 'fs'
// npm
import { render } from 'mustache'
// internal
import { Config, SunriseSunset } from './sunnyt'

const cfg: Config = require('./config.json')

const outfile: string = './sunnyt.html'
const template: string = './output.mst'

/**
 * main runtime, call `renderTemplate` and create a HTTP server on
 * port 8000 serving the HTML output
**/
try {
  readFile(template, async (err, mst) => {
    if (err) throw err
    const html = await renderTemplate(mst.toString())
    const server = createServer(async (request, response) => {
      response.writeHead(200, { "Content-Type": "text/html" })
      response.write(html)
      response.end()
    })
    console.log('Serving content on http://localhost:8080/')
    server.listen(8000)
  })
} catch (err) {
  console.error(err)
}

/**
 * Generate a dataset (using `initDataset()` and `requestData()`).
 * Then format that data to be used with `render` against the `template` file.
**/
function renderTemplate(templateString): Promise<string> {
  return new Promise((resolve) => {
    requestData(cfg, initDataset(cfg)).then((dataset: SunriseSunset[]) => {
      if (dataset.length === 0)
        console.error('empty dataset')

      const earliestIndex = findEarliestSunrise(dataset)
      const outputData = {
        data: dataset.map((data, index) => formatData(data, index)),
        datasize: dataset.length,
        earliest: formatData(dataset[earliestIndex], earliestIndex)
      }

      resolve(render(templateString, outputData))
    })
  })
}

/**
 * Find the index of the item in `dataset` with the earliest `.data.sunrise`.
**/
function findEarliestSunrise(dataset: SunriseSunset[]): number {
  let earliestIndex: number = 0
  dataset.forEach((item, index) => {
    if (index === 0 || item.data === undefined)
      return
    if (item.data.sunrise > dataset[earliestIndex].data.sunrise)
      earliestIndex = index
  })
  return earliestIndex
}

/**
 * Format a `SunriseSunset` into an object to be parsed by the output template
**/
function formatData(item: SunriseSunset, id: number): Object {
  return {
    id: id+1, // 1-n instead of 0-n
    lat: item.lat,
    lng: item.lng,
    sunrise: (item.data === undefined) ? 'no data' : item.data.sunrise.toUTCString(),
    daylen: (item.data === undefined) ? 'no data' : item.data.dayLength.toTimeString()
  }
}


/**
 * initDataset initialsies a `SunriseSunset[]` of size `cfg.datasetSize`.
 * All constructor values of the generates datas are left blank and
 * get generated by the class constructor (see #SunriseSunset).
**/
function initDataset(cfg: Config): SunriseSunset[] {
  let ds: SunriseSunset[] = []
  for (let i = 0; i < cfg.datasetSize; i++)
    ds.push(new SunriseSunset())
  return ds
}

/**
 * requestData calls the `.requestData()` of all items in `dataset`.
 * The number of concurrent requests made is limited by `cfg.requestLimit`,
 * these requests are made in batches - the next batch is requested after
 * all responses from the previous batch have been recieved.
 * The returned `SunriseSunset[]` of the returned `Promise` will be `dataset`
 * with it's `.data` variable updated (using `.requestData()`).
**/
function requestData(cfg: Config, dataset: SunriseSunset[]): Promise<SunriseSunset[]> {
  return new Promise<SunriseSunset[]>(async(resolve) => {
    for (let index = 0; index < dataset.length; index += cfg.requestLimit) {
      let numReqs: number
      if (index + cfg.requestLimit > dataset.length)
        numReqs = dataset.length
      else
        numReqs = index + cfg.requestLimit
      
      let reqs: Promise<void>[] = []
      for (let r = index; r < numReqs; r++)
        reqs.push(dataset[r].requestData().catch(console.error))

      stdout.write(`${index + cfg.requestLimit}/${dataset.length} requests...\r`)
      await Promise.all(reqs)
    }
    stdout.write('\n')
    resolve(dataset)
  })
}
