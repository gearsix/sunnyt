import { stdout } from 'process'
import { Config, SunriseSunset } from './sunnyt'

const cfg: Config = require('./config.json')

/**
 * main function, calls `initDataset` -> `requestData` and then
 * prints the (formatted) `dataset` to console for user and finds
 * dataset the item with the earliest sunrise time.
**/
requestData(cfg, initDataset(cfg)).then((dataset: SunriseSunset[]) => {
  if (dataset.length === 0) {
    console.error('empty dataset!')
    return
  }

  console.log('\nSUNRISE TIMES')
  console.log(`\t id| ${('latitude').padEnd(11)}| ${('longitude').padEnd(11)} | sunrise`)
  let earliest = -1, voidDates = 0
  for (let i = 0; i < dataset.length; i++) {
    let d = dataset[i]

    if (d.data === undefined) {
      console.log(`\t${i.toString().padStart(3)}| data undefined, skipping`)
      continue
    }

    let dstr = `${i.toString().padStart(3)}|${d.latString()},${d.lngString()} = ${d.sunriseString()}`
    if (d.data.sunrise.getFullYear() == 1970) {
      console.log(`\t${dstr} - void date`)
      voidDates++
      continue
    } else {
      console.log(`\t${dstr}`)
    }

    if (earliest === -1)
      earliest = i
    else if (dataset[earliest].data.sunrise > d.data.sunrise)
      earliest = i
  }

  if (voidDates > 0)
    console.log('\n"void date" = coordinates not supported by sunrise-sunset.org, ignore results\n')
  
  if (earliest === -1)
    console.error("\nnot enough valid data retrieved, aborting")
  else {
    let e = dataset[earliest]
    console.log(`EARLIEST ${earliest}`)
    console.log(`\tcoordinates: ${e.lat},${e.lng}`)
    console.log(`\tsunrise:     ${e.sunriseString()}`)
    console.log(`\tday length:  ${e.data.dayLength.toTimeString()}`)
  }
})

/**
 * initDataset initialsies a `SunriseSunset[]` of size `cfg.datasetSize`.
 * All constructor values of the generates datas are left blank and
 * get generated by the class constructor (see #SunriseSunset).
**/
function initDataset(cfg: Config): SunriseSunset[] {
  let ds: SunriseSunset[] = []
  for (let i = 0; i < cfg.datasetSize; i++)
    ds.push(new SunriseSunset())
  return ds
}

/**
 * requestData calls the `.requestData()` of all items in `dataset`.
 * The number of concurrent requests made is limited by `cfg.requestLimit`,
 * these requests are made in batches - the next batch is requested after
 * all responses from the previous batch have been recieved.
 * The returned `SunriseSunset[]` of the returned `Promise` will be `dataset`
 * with it's `.data` variable updated (using `.requestData()`).
**/
function requestData(cfg: Config, dataset: SunriseSunset[]): Promise<SunriseSunset[]> {
    return new Promise<SunriseSunset[]>(async(resolve) => {
    for (let i = 0; i < dataset.length; i += cfg.requestLimit) {
      let j = (i + cfg.requestLimit > dataset.length) ? dataset.length : i + cfg.requestLimit
      
      let reqs: Promise<void>[] = []
      for (let r = i; r < j; r++)
        reqs.push(dataset[r].requestData().catch((err) => { console.error(err) }))

      stdout.write(`${i+cfg.requestLimit}/${dataset.length} requests...\r`)
      await Promise.all(reqs)
    }
    stdout.write('\n')
    resolve(dataset)
  })
}
